# -*- coding: utf-8 -*-
"""class_with _affect_rcv.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15hMIoJp04Cb78A61dJEZZBGR7N5LVUKW
"""

# -*- coding: utf-8 -*-
"""Untitled38.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ROSIi-Jd_An7Socd58HF5j6DvO2YGRk7
"""

from geopy.distance import geodesic
import pandas as pd
import numpy as np
import time
#
class vrp_by_geopy:
    #
    def __init__(self,clients,cars,coordonne,init):
        self.clients=clients
        self.cars=cars
        self.coordonne=coordonne
        self.init=init
    #
    def create_distance_matrix(self):
        matrix=[]
        for cor in self.coordonne:
            distance=list(map(lambda x:float(str(geodesic(cor,x)).strip('km')),self.coordonne))
            matrix.append(distance)
        #
        return matrix
    #
    def vector_init_distance(self):
        init_dis=list(zip(list(map(lambda x:float(str(geodesic(self.init,x)).strip('km')),self.coordonne)),self.clients))
        return init_dis
    #
    def matrix_to_df(self,matrix):
        df=pd.DataFrame(data=matrix,columns=self.clients,index=self.clients)
        #
        return df
    #
    def affec(self,dict_client_distnace,init,list_client):
      result = []
      dict_position_trie_by_client={}
      for k, v in dict_client_distnace.items():
        list_position_trie = sorted(v)
        dict_position_trie_by_client[k] = [x for x in list_position_trie if x[1] in list_client]
      #
      #
      for i in list_client:
        result.append(init)
        index = 1
        for x in list_client[:-2]:
            if dict_position_trie_by_client[init][index][1] in result:
                index += 1
            else:
                init = dict_position_trie_by_client[init][index][1]
                break
      return result
    #
    #
    def ajout(self,client, k, data):
        result = self.clients[:k]
        new_list_client = self.clients[k:]
        new_list_client.append(client)
        #
        d = {}
        #
        for c in new_list_client:
            # print(data[c].index)
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        d[client] = list(zip(list(data[client]), list(data[client].index)))
        #
        trie = self.affec(d, new_list_client[0], new_list_client)
        return (result + trie)
    #
    def vrp_init(self,dipo_ds, matrix):
        sol = {}
        result = []
        rslt = []
        dipo = [x for x in dipo_ds if x[1] in self.clients]
        dipo = sorted(dipo)
        # print('dipo \n',dipo)
        #
        sol[self.cars[0]] = dipo[0]
        result.append(sol)
        rslt.append({self.cars[0]: [dipo[0][1]]})
        # print("result ==>",result)
        for v in self.cars[1:]:
            # print('v ===>',v)
            sol = {}
            chemin = [list(x.values())[0][1] for x in result]
            # print('chemin ==>',chemin)
            rest = [x for x in self.clients if x not in chemin]
            #
            dis = {}
            for r in rest:
                s = 0
                for n in chemin:
                    a = matrix.loc[r][n]
                    b = matrix.loc[n][r]
                    if a > b:
                        s += a
                    else:
                        s += b
                dis[s] = r
            dis = sorted(dis.items(), key=lambda item: item[1])
            # print('dis ===>', dis)
            max = dis[-1]
            #
            # print('max===>',max[1])
            sol[v] = max
            #
            result.append(sol)
            rslt.append({v: [max[1]]})

        # return result
        return rslt
    #
    def annulation(self,client, k,clients,data):
        result = clients[:k]
        list_client = clients[k:]
        list_client.remove(client)
        #
        d = {}
        #p = []
        print(list_client)
        for c in list_client:
            # print(data[c].index)
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        #
        trie = self.affec(d, list_client[0],list_client)
        return result + trie
    #
    def convert(self,data):
        d = {}
        for c in self.clients:
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        return d

    def compare(self,init_vrp,all_tourne):
        basket = []
        rslt = []
        for index in range(len(all_tourne[0])):
            # print(index)
            for line in list(zip(all_tourne, self.cars)):
                # print(line[0][index])
                if line[0][index] not in basket:
                    rslt.append((line[1], line[0][index]))
                    basket.append(line[0][index])
        return rslt
    #
    def affect(slef,init, list_clients_rest, dict_client):
        #print('affect ===>',dict_client,'list rest ===>',list_clients_rest)
        new_dict = [x for x in dict_client[init] if x[1] in list_clients_rest]
        return new_dict

    #
    def min_dis(self,list_dis_client):
        list_dis_client = sorted(list_dis_client)
        return list_dis_client[0][1]

    #
    def list_client_rest(self,init_dict):
        full = []
        # main
        for x in init_dict:
            init = list(x.values())[0][-1]
            #
            if init not in full:
                full.append(init)
            #
        return [x for x in self.clients if x not in full]

    #
    def affectation_client (self,init_vrp,dict_client):
        #
        init_vrp_copy=init_vrp
        rest=self.list_client_rest(init_vrp_copy)
        #
        while (len(rest) != 0):

            for x in init_vrp_copy:
                init = list(x.values())[0][-1]
                aff = self.affect(init, rest, dict_client)
                nrml = self.min_dis(aff)
                v = list(x.keys())[0]
                x[v].append(nrml)
                rest.remove(nrml)
                if len(rest) == 0:
                    break
        #print("result ==>", init_vrp_copy)
        return init_vrp_copy
    #
    def possible(self,df,init_tourn):
        all_affec = []  # this list for recive all affect posible
        df_to_dict = self.convert(df)
        for x, c in enumerate(init_tourn):
            init = list(init_tourn[x].values())[0]
            all_affec.append(self.affec(df_to_dict, init))
        return all_affec
    #
    def affected(self, optmz_list):
        aff = []
        for v in self.cars:
            d = {}
            d[v] = [y for x, y in optmz_list if x == v]
            aff.append(d)
        return (aff)
    #
    def __repr__(self):
        return f"{self.clients}{self.cars}"
    #

if __name__ == '__main__':
    data=pd.read_excel('testdata.xls')
    list_client=list(data['Client '])
    crdn=list(zip(list(data['latitude']),list(data['longitude'])))
    start=time.time()
    #list_client=['c1','c4','c5','c2','c8','c9','cr']
    depo=(36.7149768,3.2094611)
    vendeur=['v1','v2','v3','v4','v5']
    #crdn=[(70,40),(55,15),(46,12),(9,13),(71,87),(12,39),(75,52)]
    tour=vrp_by_geopy(list_client,vendeur,crdn,depo)
    print('######### create class vrp #########')
    print(tour)
    distance_matrix=tour.create_distance_matrix()
    print('##### convert the matrix to df ######')
    df_matrix=tour.matrix_to_df(distance_matrix)
    print('dataframe matrix ===> \n',df_matrix)
    print('## the vecture of the init piont #####')
    init_vec=tour.vector_init_distance()
    print('init vecture ===> \n',init_vec)
    print('##### initialistion the clients ######')
    dist_init=tour.vrp_init(init_vec,df_matrix)
    print('the dict of client with car ===>: \n',dist_init )
    print('#### Show all affectation ############')
    all=tour.convert(df_matrix)
    print('all possible affect ===> \n',all)
    print("############ norlamisation ########")
    affect_dict=tour.affectation_client(dist_init,all)
    print('dict_init ====>',affect_dict)
    print('######### Time execution ###########')
    fin=time.time()
    print(fin-start)
    for x in affect_dict:
      print("show nb client  ========>",len(list(x.values())[0]))

for x in affect_dict:
  print(x,"\n")

total=[]
for x in affect_dict:
  d={}
  s=[i[0] for i in init_vec if i[1]==list(x.values())[0][0]]
  #print(x)
  for y,z in enumerate(list(x.values())[0][1:-1]):
    #print(list(x.values())[0][y])
    a=list(x.values())[0][y]
    #print(list(x.values())[0][y+1])
    b=list(x.values())[0][y+1]
    s+=df_matrix.loc[a][b]
    #print('============================================================')
  d[list(x.keys())[0]]=s
  total.append(d)
#
print(total)
m=(list(zip(list(df_matrix.max()),list(df_matrix.max().index))))
c=sorted(m)[-1]
print(c)

for x in affect_dict:
  print(x)
  if 'C0129' in (list(x.values())[0]):
    print(x.keys())
    break

for x in affect_dict:
  if 'C0129' in (list(x.values())[0]):
    print(list(x.values())[0])
    print(tour.annulation('C0129',9,list(x.values())[0],df_matrix))
    break

def convert(clients,data):
        d = {}
        for c in clients:
            d[c] = list(zip(list(data[c]), list(data[c].index)))
        return d

def affec_1(dict_client_distnace,init,list_client):
    result = []
    dict_position_trie_by_client={}
    for k, v in dict_client_distnace.items():
        list_position_trie = sorted(v)
        dict_position_trie_by_client[k] = [x for x in list_position_trie if x[1] in list_client]
    #
    #
    for i in list_client:
        result.append(init)
        index = 1
        for x in list_client[:-2]:
            if dict_position_trie_by_client[init][index][1] in result:
                index += 1
            else:
                init = dict_position_trie_by_client[init][index][1]
                break
    return result

def vrp_init(list_client,dipo_ds,matrice,list_vondeur):
    sol={}
    result=[]
    rslt=[]
    dipo=[x for x in dipo_ds if x[1] in list_client]
    dipo=sorted(dipo)
    #print('dipo \n',dipo)
    #
    sol[list_vondeur[0]]= dipo[0]
    result.append(sol)
    rslt.append({list_vondeur[0]:dipo[0][1]})
    #print("result ==>",result)
    for v in list_vondeur[1:]:
      #print('v ===>',v)
      sol={}
      chemin=[list(x.values())[0][1] for x in result]
      #print('chemin ==>',chemin)
      rest=[x for x in list_client if x not in chemin]
            #
      dis={}
      for r in rest:
        s=0
        for n in chemin:
          a=matrice.loc[r][n]
          b=matrice.loc[n][r]
          if a>b:
            s+=a
          else:
            s+=b
        dis[s]=r
      dis=sorted(dis.items(),key=lambda item:item[1])
      #print('dis ===>', dis)
      max=dis[-1]
            #
      #print('max===>',max[1])
      sol[v]=max
            #
      result.append(sol)
      rslt.append({v:max[1]})

    #return result
    return rslt
#

T=[[0, 25, 10, 7, 8, 9, 12, 4, 16, 12, 10, 11, 2, 8], [25, 0, 8, 6, 15, 3, 20, 9, 10, 8, 12, 3, 2, 5], [10, 8, 0, 4, 6, 10, 8, 5, 3, 4, 17, 9, 10, 13], [7, 6, 5, 0, 4, 3, 2, 7, 9, 12, 8, 6, 10, 17], [8, 15, 6, 3, 0, 9, 11, 10, 6, 13, 20, 7, 6, 5], [9, 20, 10, 2, 3, 0, 21, 19, 10, 12, 13, 14, 9, 8], [12, 9, 8, 7, 5, 12, 0, 10, 10, 12, 8, 22, 9, 10], [4, 10, 5, 9, 10, 12, 9, 0, 9, 12, 15, 11, 18, 19], [16, 8, 3, 12, 6, 11, 7, 9, 0, 6, 12, 9, 8, 5], [12, 12, 4, 8, 13, 21, 10, 8, 9, 0, 11, 5, 7, 8], [10, 3, 17, 6, 20, 13, 15, 6, 7, 11, 0, 8, 16, 15], [11, 2, 9, 10, 7, 8, 15, 12, 8, 3, 6, 0, 19, 16], [2, 5, 10, 12, 6, 17, 11, 7, 13, 7, 8, 9, 0, 14], [8, 6, 13, 7, 5, 18, 9, 12, 8, 12, 19, 17, 15, 0]]

name_client = ["c" + str(x) for x in range(len(T[0]))]
    #
    #  
df = pd.DataFrame(data=T, columns=name_client, index=name_client)
print(df)
a= convert(name_client,df)
print(a)

def ajout(self,client, k, data):
  result = self.clients[:k]
  new_list_client = self.clients[k:]
  new_list_client.append(client)
        #
  d = {}
        #
  for c in new_list_client:
    # print(data[c].index)
    d[c] = list(zip(list(data[c]), list(data[c].index)))
    d[client] = list(zip(list(data[client]), list(data[client].index)))
        #
    trie = self.affec(d, new_list_client[0], new_list_client)
  return (result + trie)

list_client =['c1','c4','c5','c2','c8','c9']
ds=[(70,'c1'),(55,'c4'),(46,'c5'),(9,'c2'),(71,'c8'),(12,'c9'),(14,'c10')]
vendeur=['v1','v2','v3','v4']
print(vrp_init(list_client,ds,df,vendeur))

def affec_rcv(init,list_client,dict_client_distance,result):
  if len(list_client) == 1:
    result.append(list_client[-1])
    return result
  else:
    list_dist=dict_client_distance[init]
    list_dist=sorted(list_dist)
    #print(list_dist)
    list_dist=[x for x in list_dist if x[1] in list_client]
    #print(list_dist)
    #
    next=list_dist[0][1]
    list_client.remove(next)
    #
    #print(next)
    result.append(next)
    return affec_rcv(next,list_client,dict_client_distance,result)
    #return next

def affec_rcv(init,list_client,dict_client_distance,result):
  if len(list_client) == 1:
    result.append(list_client[-1])
    return result
  else:
    list_dist=dict_client_distance[init]
    list_dist=sorted(list_dist)
    list_dist=[x for x in list_dist if x[1] in list_client]
    next=list_dist[0][1]
    list_client.remove(next)
    result.append(next)
    return affec_rcv(next,list_client,dict_client_distance,result)

s=time.time()
print(affec_rcv('c2',['c1','c4','c5','c8','c9'],a,result=[]))
f=time.time()
print("time ==>",f-s)

s=time.time()
print(affec_1(a,'c2',['c1','c4','c5','c8','c2','c9']))
f=time.time()
print("time ==>",f-s)

